/* App.svelte generated by Svelte v3.52.0 */
import {
	SvelteComponent,
	add_render_callback,
	add_transform,
	append,
	attr,
	check_outros,
	create_animation,
	create_in_transition,
	create_out_transition,
	detach,
	element,
	fix_and_outro_and_destroy_block,
	fix_position,
	group_outros,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out,
	update_keyed_each
} from "svelte/internal";

import { quintOut } from 'svelte/easing';
import { crossfade } from 'svelte/transition';
import { flip } from 'svelte/animate';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[12] = list;
	child_ctx[13] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[14] = list;
	child_ctx[15] = i;
	return child_ctx;
}

// (58:2) {#each todos.filter(t => !t.done) as todo (todo.id)}
function create_each_block_1(key_1, ctx) {
	let label;
	let input;
	let t0;
	let t1_value = /*todo*/ ctx[11].description + "";
	let t1;
	let t2;
	let button;
	let t4;
	let label_intro;
	let label_outro;
	let rect;
	let stop_animation = noop;
	let current;
	let mounted;
	let dispose;

	function input_change_handler() {
		/*input_change_handler*/ ctx[6].call(input, /*each_value_1*/ ctx[14], /*todo_index_1*/ ctx[15]);
	}

	function click_handler() {
		return /*click_handler*/ ctx[7](/*todo*/ ctx[11]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			label = element("label");
			input = element("input");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			button = element("button");
			button.textContent = "x";
			t4 = space();
			attr(input, "type", "checkbox");
			attr(input, "class", "svelte-147vg86");
			attr(button, "class", "svelte-147vg86");
			attr(label, "class", "svelte-147vg86");
			this.first = label;
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, input);
			input.checked = /*todo*/ ctx[11].done;
			append(label, t0);
			append(label, t1);
			append(label, t2);
			append(label, button);
			append(label, t4);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", input_change_handler),
					listen(button, "click", click_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*todos*/ 1) {
				input.checked = /*todo*/ ctx[11].done;
			}

			if ((!current || dirty & /*todos*/ 1) && t1_value !== (t1_value = /*todo*/ ctx[11].description + "")) set_data(t1, t1_value);
		},
		r() {
			rect = label.getBoundingClientRect();
		},
		f() {
			fix_position(label);
			stop_animation();
			add_transform(label, rect);
		},
		a() {
			stop_animation();
			stop_animation = create_animation(label, rect, flip, {});
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (label_outro) label_outro.end(1);
				label_intro = create_in_transition(label, /*receive*/ ctx[2], { key: /*todo*/ ctx[11].id });
				label_intro.start();
			});

			current = true;
		},
		o(local) {
			if (label_intro) label_intro.invalidate();
			label_outro = create_out_transition(label, /*send*/ ctx[1], { key: /*todo*/ ctx[11].id });
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			if (detaching && label_outro) label_outro.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (73:2) {#each todos.filter(t => t.done) as todo (todo.id)}
function create_each_block(key_1, ctx) {
	let label;
	let input;
	let t0;
	let t1_value = /*todo*/ ctx[11].description + "";
	let t1;
	let t2;
	let button;
	let t4;
	let label_intro;
	let label_outro;
	let rect;
	let stop_animation = noop;
	let current;
	let mounted;
	let dispose;

	function input_change_handler_1() {
		/*input_change_handler_1*/ ctx[8].call(input, /*each_value*/ ctx[12], /*todo_index*/ ctx[13]);
	}

	function click_handler_1() {
		return /*click_handler_1*/ ctx[9](/*todo*/ ctx[11]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			label = element("label");
			input = element("input");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			button = element("button");
			button.textContent = "x";
			t4 = space();
			attr(input, "type", "checkbox");
			attr(input, "class", "svelte-147vg86");
			attr(button, "class", "svelte-147vg86");
			attr(label, "class", "svelte-147vg86");
			this.first = label;
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, input);
			input.checked = /*todo*/ ctx[11].done;
			append(label, t0);
			append(label, t1);
			append(label, t2);
			append(label, button);
			append(label, t4);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", input_change_handler_1),
					listen(button, "click", click_handler_1)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*todos*/ 1) {
				input.checked = /*todo*/ ctx[11].done;
			}

			if ((!current || dirty & /*todos*/ 1) && t1_value !== (t1_value = /*todo*/ ctx[11].description + "")) set_data(t1, t1_value);
		},
		r() {
			rect = label.getBoundingClientRect();
		},
		f() {
			fix_position(label);
			stop_animation();
			add_transform(label, rect);
		},
		a() {
			stop_animation();
			stop_animation = create_animation(label, rect, flip, {});
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (label_outro) label_outro.end(1);
				label_intro = create_in_transition(label, /*receive*/ ctx[2], { key: /*todo*/ ctx[11].id });
				label_intro.start();
			});

			current = true;
		},
		o(local) {
			if (label_intro) label_intro.invalidate();
			label_outro = create_out_transition(label, /*send*/ ctx[1], { key: /*todo*/ ctx[11].id });
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			if (detaching && label_outro) label_outro.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let h1;
	let t1;
	let div2;
	let input;
	let t2;
	let div0;
	let h20;
	let t4;
	let each_blocks_1 = [];
	let each0_lookup = new Map();
	let t5;
	let div1;
	let h21;
	let t7;
	let each_blocks = [];
	let each1_lookup = new Map();
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*todos*/ ctx[0].filter(func);
	const get_key = ctx => /*todo*/ ctx[11].id;

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
	}

	let each_value = /*todos*/ ctx[0].filter(func_1);
	const get_key_1 = ctx => /*todo*/ ctx[11].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			h1 = element("h1");
			h1.textContent = "Chicken Coop Chores";
			t1 = space();
			div2 = element("div");
			input = element("input");
			t2 = space();
			div0 = element("div");
			h20 = element("h2");
			h20.textContent = "to do";
			t4 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t5 = space();
			div1 = element("div");
			h21 = element("h2");
			h21.textContent = "done";
			t7 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h1, "class", "svelte-147vg86");
			attr(input, "class", "new-todo svelte-147vg86");
			attr(input, "placeholder", "what needs to be done?");
			attr(h20, "class", "svelte-147vg86");
			attr(div0, "class", "left svelte-147vg86");
			attr(h21, "class", "svelte-147vg86");
			attr(div1, "class", "right svelte-147vg86");
			attr(div2, "class", "board svelte-147vg86");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			insert(target, t1, anchor);
			insert(target, div2, anchor);
			append(div2, input);
			append(div2, t2);
			append(div2, div0);
			append(div0, h20);
			append(div0, t4);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			append(div2, t5);
			append(div2, div1);
			append(div1, h21);
			append(div1, t7);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(input, "keydown", /*keydown_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*todos, remove*/ 17) {
				each_value_1 = /*todos*/ ctx[0].filter(func);
				group_outros();
				for (let i = 0; i < each_blocks_1.length; i += 1) each_blocks_1[i].r();
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div0, fix_and_outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
				for (let i = 0; i < each_blocks_1.length; i += 1) each_blocks_1[i].a();
				check_outros();
			}

			if (dirty & /*todos, remove*/ 17) {
				each_value = /*todos*/ ctx[0].filter(func_1);
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, div1, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (detaching) detach(t1);
			if (detaching) detach(div2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			dispose();
		}
	};
}

const func = t => !t.done;
const func_1 = t => t.done;

function instance($$self, $$props, $$invalidate) {
	const [send, receive] = crossfade({
		fallback(node, params) {
			const style = getComputedStyle(node);
			const transform = style.transform === 'none' ? '' : style.transform;

			return {
				duration: 600,
				easing: quintOut,
				css: t => `
					transform: ${transform} scale(${t});
					opacity: ${t}
				`
			};
		}
	});

	let todos = [
		{
			id: 1,
			done: false,
			description: 'feed the chickens'
		},
		{
			id: 2,
			done: false,
			description: 'change/ freshen water'
		},
		{
			id: 3,
			done: true,
			description: 'collect eggs'
		},
		{
			id: 4,
			done: false,
			description: 'scoop poop in coop'
		},
		{
			id: 5,
			done: false,
			description: 'refresh nest boxes'
		},
		{
			id: 6,
			done: false,
			description: 'observe the chickens'
		}
	];

	let uid = todos.length + 1;

	function add(input) {
		const todo = {
			id: uid++,
			done: false,
			description: input.value
		};

		$$invalidate(0, todos = [todo, ...todos]);
		input.value = '';
	}

	function remove(todo) {
		$$invalidate(0, todos = todos.filter(t => t !== todo));
	}

	const keydown_handler = event => event.key === 'Enter' && add(event.target);

	function input_change_handler(each_value_1, todo_index_1) {
		each_value_1[todo_index_1].done = this.checked;
		$$invalidate(0, todos);
	}

	const click_handler = todo => remove(todo);

	function input_change_handler_1(each_value, todo_index) {
		each_value[todo_index].done = this.checked;
		$$invalidate(0, todos);
	}

	const click_handler_1 = todo => remove(todo);

	return [
		todos,
		send,
		receive,
		add,
		remove,
		keydown_handler,
		input_change_handler,
		click_handler,
		input_change_handler_1,
		click_handler_1
	];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;
